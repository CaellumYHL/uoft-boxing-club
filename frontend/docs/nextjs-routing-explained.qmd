---
title: "Next.js Navbar Routing Explained"
subtitle: "How routing works differently from regular HTML/JS"
author: "UofT Boxing Club Dev"
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 3
    code-fold: false
    highlight-style: github-dark
---

## Introduction

This document explains how the navbar routing in our Next.js app works, using regular HTML/JavaScript as a baseline for comparison. If you've built websites with plain HTML before, this will help you understand what Next.js does differently ‚Äî and **why** the `basePath` bug happened.

---

## 1. Page Navigation

### Regular HTML/JS

In a traditional multi-page website, each page is a separate `.html` file. The browser makes a **full HTTP request** for every navigation:

```html
<!-- navbar.html (copied into every page) -->
<nav>
  <a href="/index.html">HOME</a>
  <a href="/store.html">STORE</a>
  <a href="/team.html">TEAM</a>
</nav>
```

- Clicking "STORE" causes the browser to request `store.html` from the server.
- The entire page reloads: HTML, CSS, JS ‚Äî everything re-fetched and re-parsed.
- There is a visible white flash or loading delay between pages.

### Next.js

Next.js uses **client-side routing**. Instead of `<a>` tags, we use the `<Link>` component:

```tsx
import Link from 'next/link';

<Link href="/store">STORE</Link>
<Link href="/team">MEET OUR TEAM</Link>
```

**What actually happens when you click:**

1. Next.js **intercepts** the click (prevents the default browser navigation).
2. It fetches **only the new page's component data** (a small JSON payload), not the full HTML.
3. It swaps out just the page content, keeping the navbar, layout, and state intact.
4. The URL in the address bar updates via the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) ‚Äî no full page reload.

This is called **Single Page Application (SPA)** behavior. The HTML file is loaded once, and JavaScript handles all subsequent "navigation."

---

## 2. Hash Links (Scroll-to-Section)

### Regular HTML/JS

To scroll to a section on the same page, you use hash links:

```html
<!-- Same-page scroll -->
<a href="#classes">CLASSES</a>
<a href="#events">EVENTS</a>

<!-- The target sections -->
<section id="classes">...</section>
<section id="events">...</section>
```

If you're on a **different page** and want to scroll to a section on the home page:

```html
<!-- From store.html, go to home page and scroll to #classes -->
<a href="/index.html#classes">CLASSES</a>
```

The browser handles everything: it navigates to the page, then scrolls to the element with that `id`.

### Next.js

In Next.js, hash links work similarly but with a key distinction ‚Äî we need to handle **two cases**:

```tsx
// Our Navbar's getHref function
const getHref = (section: string) =>
  pathname === '/' ? `#${section}` : `/#${section}`;
```

| Situation | href | What happens |
|-----------|------|--------------|
| Already on home page (`/`) | `#classes` | Smooth scroll to section (no navigation) |
| On another page (`/store`) | `/#classes` | Navigate to home, then scroll to section |

The `<Link>` component handles both cases seamlessly ‚Äî it uses the History API for the navigation part and lets the browser handle the hash scrolling.

---

## 3. The `basePath` Concept

### Regular HTML/JS

In plain HTML, if your site is hosted at a subpath like `https://example.com/my-app/`, you manually adjust **every single link**:

```html
<!-- You have to hardcode the subpath everywhere -->
<a href="/my-app/store.html">STORE</a>
<a href="/my-app/team.html">TEAM</a>
<img src="/my-app/images/logo.png" />
<link rel="stylesheet" href="/my-app/styles.css" />
```

This is tedious and error-prone. If the subpath changes, you update every link.

### Next.js

Next.js has a `basePath` config that handles this **automatically**:

```ts
// next.config.ts
const nextConfig = {
  basePath: '/uoft-boxing-club',
};
```

Once set, **all** `<Link>` and `<Image>` components automatically prepend the basePath:

```tsx
// You write:
<Link href="/store">STORE</Link>
<Image src="/favicon.ico" />

// Next.js renders:
<a href="/uoft-boxing-club/store">STORE</a>
<img src="/uoft-boxing-club/favicon.ico" />
```

You **never** manually add the basePath to component hrefs ‚Äî Next.js does it for you.

---

## 4. What Caused Our Bug üêõ

### The Double-Path Bug

Our `getHref` function was **manually** prepending `basePath`:

```tsx
// ‚ùå BROKEN ‚Äî manual basePath + Link's automatic basePath = doubled!
const basePath = '/uoft-boxing-club';
const getHref = (section) =>
  pathname === '/' ? `#${section}` : `${basePath}/#${section}`;
```

When you clicked "CLASSES" from the Store page, this happened:

```
getHref returns:        /uoft-boxing-club/#classes
<Link> auto-prepends:   /uoft-boxing-club/uoft-boxing-club/#classes  ‚Üê DOUBLED!
```

### The Fix

Remove the manual basePath from `getHref` and let `<Link>` handle it:

```tsx
// ‚úÖ FIXED ‚Äî only <Link> adds the basePath
const getHref = (section) =>
  pathname === '/' ? `#${section}` : `/#${section}`;
```

Now:

```
getHref returns:        /#classes
<Link> auto-prepends:   /uoft-boxing-club/#classes  ‚Üê Correct!
```

### The 404 Bug

The `basePath` was hardcoded to always be `/uoft-boxing-club`, even during local development:

```ts
// ‚ùå BROKEN ‚Äî dev server serves at localhost:3000/uoft-boxing-club
basePath: '/uoft-boxing-club',
```

Fix: make it conditional:

```ts
// ‚úÖ FIXED ‚Äî only apply basePath in production (GitHub Pages)
const isProd = process.env.NODE_ENV === 'production';
basePath: isProd ? '/uoft-boxing-club' : '',
```

---

## 5. `basePath` vs `assetPrefix`

These two configs are related but different:

| Config | What it affects | Example |
|--------|----------------|---------|
| `basePath` | Page routes, `<Link>`, `<Image>` | `/uoft-boxing-club/store` |
| `assetPrefix` | Static assets (JS bundles, CSS, fonts, favicon) | `/uoft-boxing-club/_next/static/...` |

For GitHub Pages, we need **both** so that pages AND assets resolve correctly:

```ts
const nextConfig = {
  basePath: isProd ? '/uoft-boxing-club' : '',
  assetPrefix: isProd ? '/uoft-boxing-club/' : undefined,
};
```

In regular HTML, there's no equivalent ‚Äî you just hardcode every path manually.

---

## 6. Scroll Spy (Bonus)

Our navbar highlights the current section as you scroll. This is pure JavaScript, same concept in both approaches:

### Regular HTML/JS

```javascript
// Vanilla JS scroll spy
const sections = document.querySelectorAll('section[id]');
window.addEventListener('scroll', () => {
  sections.forEach(section => {
    if (isInViewport(section)) {
      highlightNavLink(section.id);
    }
  });
});
```

### Next.js (Our Implementation)

```tsx
// React version using IntersectionObserver (more performant)
useEffect(() => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        setActiveSection(entry.target.id);
        window.history.replaceState(null, '', `/#${entry.target.id}`);
      }
    });
  }, { threshold: 0.3 });

  sections.forEach(id => observer.observe(document.getElementById(id)));
  return () => observer.disconnect();
}, [pathname]);
```

Key difference: React uses `useEffect` for setup/cleanup, and `IntersectionObserver` is preferred over scroll event listeners because it's more performant (doesn't fire on every pixel of scrolling).

---

## Summary

| Concept | Regular HTML/JS | Next.js |
|---------|----------------|---------|
| Navigation | Full page reload via `<a>` | Client-side swap via `<Link>` |
| Hash scrolling | `<a href="#id">` | `<Link href="#id">` (same concept) |
| Subpath hosting | Hardcode paths everywhere | `basePath` config (auto-applied) |
| Asset paths | Hardcode paths everywhere | `assetPrefix` config |
| State on navigate | Lost (page reloads) | Preserved (SPA) |
| Scroll spy | `scroll` event listener | `IntersectionObserver` in `useEffect` |

**Golden rule:** Never manually prepend `basePath` to `<Link>` or `<Image>` hrefs ‚Äî Next.js does it for you!
